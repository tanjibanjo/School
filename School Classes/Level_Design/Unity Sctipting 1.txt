Lane Pollock
Notes on unity scripting, using C#
***********************************
public class CLASS : MonoBehaviour {...functions...}

***********************************
SCRIPTS
-------
can add scripts and create within the finder(ui)

---------
VARIABLES
---------
declare and initialize variables just like cpp, semicolon to finish

	-Debug.Log() //access value of any variable in the game
		Debug.Log(myInt); //example
		-if you attach that to an object in game, press play, value is shown in the 
		 console
functions still use return type and {} - just like cpp, name functions with PascalCase
parameters same as cpp

***********************************
SYNTAX
------
-dot notation
-semicolon terminates statements, just like cpp
//for comments
/* ... */ for multiline
- floats are initialized with 'f' after the number
	ex: float num1 = 5.0f
-=, +=, *= remain


DELTA TIME - Time.deltaTime //use to keep track of time passing in a consistent manner

INPUT - Input.GetKeyDown(KeyCode.INSERT_KEY_HERE) //replace that with whatever key you want

***********************************
LOOPS
-----

- all the same as cpp!

***********************************
SCOPE
-----
always remember the access modifiers for variables defined in the class, not just in functions

- public - accessed from outside the class and editable/shown in the unity inspector**
	- good to use for testing within the editor
	- variables modified in the inspector while running will not be changed or saved**

- private - is the default modifier for variables in a class!!
	- good to write it out anyways

USE 'NEW' KEYWORD FOR CREATING INSTANCES OF CLASSES

***********************************
AWAKE AND START

- TWO SCRIPTS CALLED AUTOMATICALLY WHEN SCRIPT IS LOADED
- awake is called first and is good for setting up references between scripts and initialization
- start is called after, before the first update, but only if the script component is enabled
	- this allows you to delay any part of the init code until its needed

** these are only called once 

***********************************
UPDATE AND FIXED UPDATE
-----------------------
void Update() 
	is called every frame, and is used for all types of things 
-it is not consistent, if frames take longer than the next the update is called irregularly

void FixedUpdate()
	is will have the same amnt of time between calls
-anything that has a RigidBody should use fixed update for physics stuff

***********************************
MonoBehavior scripting wizard
-----------------------------

cntrl-SHIFT-'M' to launch wizard
	- then choose the methods you want to add
	- press okay to insert methods into the code
	- i think this lets you browse special functions available within unity to implement

***********************************
VECTORS
-------
- a line drawn between two points
- have a length, known as magnitude

2D VECTORS
	- goes from origin to any point in a plane, implying it has a direction
	- good to use for distance and relative computing
	- also used for velocity
3D VECTORS
	- work the same as 2D but extrapolated into the z axis, depth
	
Unity works on a left handed coordinate system
	- meaning, thumb is x axis, finger is y
	- finding the magnitude is the same as 2d - sqrt(x^2 + y^2 + z^2)
	HELPER FUNCTION - use Vector3.magnitude() function to get the magnitude easy!

DOT PRODUCT - takes the values of two vectors and produces a scaler, a single value
	- take their parts and multiply them together to find the sum of the products
	- (Ax * Bx) + (Ay * By) + (Az * Bz) = Dot Product
		- IF THE DOT PRODUCT OF TWO VECTORS IS 0, THEY ARE PERPENDICULAR
	HELPER FUNCTION - Vector3.Dot(VectorA, VectorB)

CROSS PRODUCT
	-instead of returning a scalar, returns a vector that is perpendicular to the first two
	Vector3.Cross(VectorA, VectorB)

	- one use is if you were wanting to apply rotational torque, 
		- if you know the direction facing, and what direction it needs to face, can 
			find the axes to rotate on
***********************************
ENABLING AND DISABLING COMPONENTS
---------------------------------
GetComponent<COMPONENT>(); //returns a component attached to the object

to enable/disable components, use the .enabled flag and set to !component.enabled; 
	-using ! to invert the value, making it a toggle instead of writing xt code
	-scripts are also components and you can use the .enable to toggle them too

- deactivating a parent object will deactivate the child component as well
- to check if active in the scene or heirarchy
	object.activeSelf();
	object.activeInHeirarchy(); //can debug.log these to see what's going on

***********************************
TRANSLATE AND ROTATE
---------------------
-translate
	- put into update()
	- transform.Translate(new Vector(0, 0, 1); // updating every frame 
		-can actually work around this by multiplying Vector3.forward (built in) by T
		 ime.deltaTime and moveSpeed
		
	- now this is meters per second, not meters per frame**
	- moving backwards, use -Vector3.forward to negate the call

-Rotate
	- transform.Rotate(Vector3.up, turnspeed (or -turnSpeed) * Time.deltaTime);
	- Vector3 works in the local axis, not the world axis
	- careful with using rotate with physics objects

***********************************
LOOK AT
-------

- make a game object look at another object in the world
INSIDE OF UPDATE:
	- can call transform.LookAt(target); //target is type transform variable in the script class
	- this look at script can attach to the camera, then apply the target object within the inspector (editor)

***********************************
LINEAR INTERPOLATION
--------------------
- finding a value that is at some percentage between two numbers 
EX: 
	float result = Mathf.Lerp(3f, 5f 0.5f); //the result is 4, which is 50% between 3 and 5

- other lerp functions are Color.Lerp and Vector3.Lerp
- can be used to smoothly transition between values in code

EX:
	(in update)
	light.intensity = Mathf.Lerp(light.intensity, 8f, 0,5f * Time.deltaTime);

***********************************
DESTROY
-------
-used to destroy an object during runtime 

use - Destroy(OBJECT)

- in the inspector, we can add an object to be removed
- also can use to destroy components instead of full objects

Destroy(GetComponent<MeeshRenderer>()); //this makes the object not visually rendered, but still in game

-this can take a number float as a time delay! -in seconds

***********************************
GETBUTTON AND GETKEY
--------------------
-uses Unity's input class

GetKey names the keys using key codes
EX:
	bool down = Input.GetKeyDown(KeyCode.Space);

-good for keyboard but recommended to make buttons and specify own controls

INPUT MANAGER gives ability to name and edit buttons
	edit - project settings - input

then you can reference using a string

------------
-these have three states that return t/f
1. GetButtonDown - returns t/f if pressed (first frame)
2. GetButton - true if holding over time, getbuttondown turns to false after first frame
3. GetButtonUp - true when released, GetButton goes false (this is also for only one frame)

-this would be real easy for sprites and stuff 

***********************************
GET AXIS
--------
- returns a float between -1 and positive 1
-edit - project settings - input menu

- gravity of the axis effects how fast the value returns to zero
- sensitivity controls how fast the control value reaches 1 or -1
- the dead zone is a zone where input is not registered, like with the joystick small movements won't register

float h = Input.GetAxis("Horizontal");
float y = input.GetAxis("Verticle");

- can also use GetAxisRaw that returns only whole numbers
	- good for 2d stuff that needs very precise control

***********************************
ON MOUSE DOWN
--------------
-can identify a click on something, whether it is a uI element or an object

void OnMouseDown(); function**

//Adding force
EX:
	rb = GetComponent<RigidBody>(); //get the collision component
	
	void OnMouseDown() {
		rb.AddForce(-Transform.forward * 500f); //apply force to the component making it move backwards
		rb.useGravity = true; //set gravity to be enabled, allowing the component to fall down
	}

***********************************
GET COMPONENT
--------------
-a script is considered a custom component
-access other scripts and components with GetComponenet<TYPE>();

-variables in one script/class that are of other scripts or objects REFERENCE an instance of that component
-can also be used to get components on other objects in the game

-get component is expensive, call it as little as possible
-good practice to call in the awake or start functions and not much else

***********************************
DELTA TIME
----------
when used in update(), Time.deltaTime is equal to the time between frames
- Time Scale can be used to 'slow down time'. This is another variable of the Time class. 
	- default value is 1, which is 1 second of game time takes 1 real world seconds.
	- in 'bullet time', this could be set to .5 to slow down the game
- you could set the menu, like a pause menu top use unscaled time, allowing normal use and the game in the meantime to have a scale of 0, stopping play in the background
***********************************
DATA TYPES
----------
value types - primitives, structs (like Vector3 and Quaternian)
reference types - classes and their variables, like transform and game object

- ref types contain the memory locations to variables
- value types store variable itself

**transform.position; = current position //returns a vector **

***********************************
CLASSES
-------
SCRIPT AND CLASS NAME HAVE TO BE THE SAME**

- dedicated to one task ideally
-constructors!
	-default values, same stuff as cpp
	-parameters and stuff

- instantiating a class
	- use 'new' keyword
	public Class myClass = new Class(parameters, or not);

-user 'ctor' to quickly set up another constructor on visual studio

***********************************
INSTANTIATE
-----------
creates clones of game objects
- example: firing projectiles

- each projectile would need to be instantiated then fired

	Instantiate(OBJECT TO CLONE); //this is the most basic version, and puts the projectile at 0 (of the world)

instead, we would use 3 parameter instantiate, taking object, position, and rotation
	
	you could then use the editor to fill in those object values after setting up the code.
	variables in the script class can be set in the editor, there is not a 'constructor' necessarily for the overarching class, since it will be attached to an object and then can be edited in the engine

	- to add force to the projectile, we can instantiate the projectile as a RigidBody, then add force to it!

	RigidBody proj;
	proj = Instantiate(projectile, barrelEnd.position, barrelEnd.rotation) as RigidBody;
	proj.AddForce(barrelEnd.up * 250f); //moving upward

*remember to remove the object as it will technically stay in world until then using Destroy

***********************************
ARRAYS
------
//syntax is a little different from cpp

int[] myArray = new int[5]

-then in start, you can initialize the array
	void Start() { //initialize }

-----
or, you can declare and initialize at the same time of course
int[] newArray = {12, 5, 3, 7, 9};

//if the array is public, you can change it in the inspector

------
say we were getting all the players in the scene, we could make an array of them using the FindGameObjectsWithTag function:

	void Start() {
		players = GameObject.FindGameObjectsWithTag("Player");
	}

iterate through the array:
	for(int i = 0; i < players.Length; i++) {
		Debug.Log("Player numer "+i+" is named "+Player[i].name);
	}

***********************************
INVOKE
------
enable you to schedule a function call after some specified time delay
-time sensitive function  call!

we could call a method in Start() {
	invoke("Method", 2);
}

//then the method would be called in 2 seconds - use string name of the function as first parameter

//NOTE - only return type void functions with no parameters can be called using Invoke

--------
INVOKE REPEATING
	-use InvokeRepeating instead of Invoke
		-it will take three parameters now
		-string name of method, delay before call, and delay between each subsequent call of the method
-to stop all instances
	-use cancelInvoke() //if you want to only cancel one method, pass the method string name as parameter

***********************************
ENUMERATIONS
------------

enum Direction {North, East, South, West}; //declare the enums in the declaration, then close the statement with ;

- you could set values as well , like {North = 20, South=15 ...}
- also could add a data type for the enum itself, instead of int
	enum Direction : short{North.....}

	-changing type can help with optimization

-then access with dot notation, like 
	Direction myDirection = Direction.North

***********************************
SWITCH STATEMENTS
------------------
just like cpp

works really well with enums

switch(var) {
	case 1:
		code...
		break;
	default:
		code...
		break;

this is just like cpp basically
